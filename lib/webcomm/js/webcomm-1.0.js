//Name: webcomm; Dependencies: adapter.jsvar webcomm = {};webcomm.url='http://localhost:3303';webcomm.room='default';webcomm.sdpConstraints = {	'mandatory': {		'OfferToReceiveAudio':true, 		'OfferToReceiveVideo':true 	}};webcomm.pc1=null;webcomm.pc2=null;webcomm.localstream=null;webcomm.socket=null; webcomm.gotStream=function(stream){	trace("Received local stream");	// Call the polyfill wrapper to attach the media stream to this element.	attachMediaStream(vid1, stream);	webcomm.localstream = stream;	if (typeof webcomm._ongotStream=='function'){		webcomm._ongotStream();	};}webcomm.ongotStream=function(fx){	webcomm._ongotStream=fx;};webcomm.onStart=function(fx){	webcomm._onStart=fx;};webcomm.start=function() {	if (typeof webcomm._onStart=='function'){		webcomm._onStart();	};		// Call into getUserMedia via the polyfill (adapter.js).	getUserMedia({audio:true, video:true}, webcomm.gotStream, function() {});	webcomm.socket = io.connect(webcomm.url);	webcomm.socket.emit('subscribe',{room: webcomm.room});		// modification: 	webcomm.socket.on('message1', function(event){		switch (event.type){		case "candidate":			webcomm.pc2.addIceCandidate(new RTCIceCandidate(event.candidate));			break;		case "offer":			webcomm.pc2.setRemoteDescription(new RTCSessionDescription(event));		  			// Since the "remote" side has no media stream we need			// to pass in the right constraints in order for it to			// accept the incoming offer of audio and video.			webcomm.pc2.createAnswer(webcomm.gotDescription2, null, webcomm.sdpConstraints);					break;		case "close":			webcomm.pc2.close();			webcomm.pc2 = null;			break;		case "open":			var servers = null;			webcomm.pc2 = new RTCPeerConnection(servers);			trace("Created remote peer connection object pc2");			webcomm.pc2.onicecandidate = webcomm.iceCallback2;			webcomm.pc2.onaddstream = webcomm.gotRemoteStream; 					break;		default:			break;		};	});  	webcomm.socket.on('message2', function(event){		switch (event.type){		case "candidate":			webcomm.pc1.addIceCandidate(new RTCIceCandidate(event.candidate));			break;		case "answer":			webcomm.pc1.setRemoteDescription(new RTCSessionDescription(event));		default:			break;		};	}); 	}   webcomm.onCall=function(fx){	webcomm._onCall=fx;};webcomm.call=function() {	if (typeof webcomm._onCall=='function'){		webcomm._onCall();	};	  videoTracks = webcomm.localstream.getVideoTracks();  audioTracks = webcomm.localstream.getAudioTracks();  if (videoTracks.length > 0)    trace('Using Video device: ' + videoTracks[0].label);    if (audioTracks.length > 0)    trace('Using Audio device: ' + audioTracks[0].label);		webcomm.socket.emit('message1',{room: 'default', type: 'open'});  var servers = null;  webcomm.pc1 = new RTCPeerConnection(servers);  trace("Created local peer connection object pc1");    webcomm.pc1.onicecandidate = webcomm.iceCallback1;   webcomm.pc1.addStream(webcomm.localstream);  trace("Adding Local Stream to peer connection");    webcomm.pc1.createOffer(webcomm.gotDescription1);}webcomm.gotDescription1=function (desc){	webcomm.pc1.setLocalDescription(desc);	trace("Offer from pc1 \n" + desc.sdp);	desc.room="default";	webcomm.socket.emit('message1', desc);    //modification:  //pc2.setRemoteDescription(desc);    // Since the "remote" side has no media stream we need  // to pass in the right constraints in order for it to  // accept the incoming offer of audio and video.  //pc2.createAnswer(gotDescription2, null, sdpConstraints);}webcomm.gotDescription2=function (desc){  webcomm.pc2.setLocalDescription(desc);  trace("Answer from pc2 \n" + desc.sdp);  desc.room="default";  webcomm.socket.emit('message2', desc);  //alert('getDescription2');  //pc1.setRemoteDescription(desc);}webcomm.onHangup=function(fx){	webcomm._onHangup=fx;};webcomm.hangup=function () {	webcomm.pc1.close(); 	webcomm.pc1 = null;	webcomm.socket.emit('message1', {room: 'default', type:"close"});	if (typeof webcomm._onHangup=='function'){		webcomm._onHangup();	};}webcomm.gotRemoteStream=function (e){  // Call the polyfill wrapper to attach the media stream to this element.  attachMediaStream(vid2, e.stream);  trace("Received remote stream");}webcomm.iceCallback1=function (event){  if (event.candidate) {		// modification: pc2 should be on socket receive to simulate remote connection    //pc2.addIceCandidate(new RTCIceCandidate(event.candidate));	// modification: start here	webcomm.socket.emit('message1',{room: 'default', type: "candidate", candidate:{					  sdpMLineIndex: event.candidate.sdpMLineIndex,					  sdpMid: event.candidate.sdpMid,					  candidate: event.candidate.candidate}});	// modification: end here					      trace("Local ICE candidate: \n" + event.candidate.candidate);  }}webcomm.iceCallback2=function (event){  if (event.candidate) {    //pc1.addIceCandidate(new RTCIceCandidate(event.candidate));		webcomm.socket.emit('message2',{room: 'default', type: "candidate", candidate:{					  sdpMLineIndex: event.candidate.sdpMLineIndex,					  sdpMid: event.candidate.sdpMid,					  candidate: event.candidate.candidate}});	    trace("Remote ICE candidate: \n " + event.candidate.candidate);  }}